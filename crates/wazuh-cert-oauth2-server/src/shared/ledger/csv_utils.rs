#[inline]
pub(super) fn split_csv_line(line: &str) -> Vec<String> {
    let mut fields = Vec::new();
    let mut cur = String::new();
    let mut in_quotes = false;
    let mut chars = line.chars().peekable();
    while let Some(c) = chars.next() {
        match c {
            '"' => {
                if in_quotes {
                    if let Some('"') = chars.peek() { cur.push('"'); let _ = chars.next(); } else { in_quotes = false; }
                } else { in_quotes = true; }
            }
            ',' if !in_quotes => { fields.push(cur); cur = String::new(); }
            _ => cur.push(c),
        }
    }
    fields.push(cur);
    fields
}

#[inline]
pub(super) fn escape_csv_field(s: &str) -> String {
    let needs_quotes = s.contains(',') || s.contains('"') || s.contains('\n') || s.contains('\r');
    if needs_quotes {
        let mut out = String::with_capacity(s.len() + 2);
        out.push('"');
        for ch in s.chars() { if ch == '"' { out.push('"'); out.push('"'); } else { out.push(ch); } }
        out.push('"');
        out
    } else { s.to_string() }
}

#[inline]
pub(super) fn unescape_csv_field(s: &str) -> String {
    let s = s.trim();
    if s.starts_with('"') && s.ends_with('"') && s.len() >= 2 {
        let inner = &s[1..s.len() - 1];
        let mut out = String::with_capacity(inner.len());
        let mut chars = inner.chars().peekable();
        while let Some(c) = chars.next() {
            if c == '"' { if let Some('"') = chars.peek() { let _ = chars.next(); out.push('"'); } } else { out.push(c); }
        }
        out
    } else { s.to_string() }
}

